{"version":3,"sources":["../../src/histogram.js"],"names":["getSeriesValues","data","values","i","length","series","j","push","convertValuesToHistogram","bucketSize","histogram","bound","getBucketBound","histogam_series","_","map","count","Number","sortBy","point","value","Math","floor"],"mappings":";;;;;;;AAEA;;;;AAIO,WAASA,eAAT,CAAyBC,IAAzB,EAA+B;AACpC,QAAIC,SAAS,EAAb;;AAEA;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,KAAKG,MAAzB,EAAiCD,GAAjC,EAAsC;AACpC,UAAIE,SAASJ,KAAKE,CAAL,CAAb;AACA,WAAK,IAAIG,IAAI,CAAb,EAAgBA,IAAID,OAAOJ,IAAP,CAAYG,MAAhC,EAAwCE,GAAxC,EAA6C;AAC3C,YAAID,OAAOJ,IAAP,CAAYK,CAAZ,EAAe,CAAf,MAAsB,IAA1B,EAAgC;AAC9BJ,iBAAOK,IAAP,CAAYF,OAAOJ,IAAP,CAAYK,CAAZ,EAAe,CAAf,CAAZ;AACD;AACF;AACF;;AAED,WAAOJ,MAAP;AACD;;AAED;;;;;;;6BAhBgBF,e;;AAsBT,WAASQ,wBAAT,CAAkCN,MAAlC,EAA0CO,UAA1C,EAAsD;AAC3D,QAAIC,YAAY,EAAhB;;AAEA,SAAK,IAAIP,IAAI,CAAb,EAAgBA,IAAID,OAAOE,MAA3B,EAAmCD,GAAnC,EAAwC;AACtC,UAAIQ,QAAQC,eAAeV,OAAOC,CAAP,CAAf,EAA0BM,UAA1B,CAAZ;AACA,UAAIC,UAAUC,KAAV,CAAJ,EAAsB;AACpBD,kBAAUC,KAAV,IAAmBD,UAAUC,KAAV,IAAmB,CAAtC;AACD,OAFD,MAEO;AACLD,kBAAUC,KAAV,IAAmB,CAAnB;AACD;AACF;;AAED,QAAIE,kBAAkBC,EAAEC,GAAF,CAAML,SAAN,EAAiB,UAACM,KAAD,EAAQL,KAAR,EAAkB;AACvD,aAAO,CAACM,OAAON,KAAP,CAAD,EAAgBK,KAAhB,CAAP;AACD,KAFqB,CAAtB;;AAIA;AACA,WAAOF,EAAEI,MAAF,CAASL,eAAT,EAA0B;AAAA,aAASM,MAAM,CAAN,CAAT;AAAA,KAA1B,CAAP;AACD;sCAlBeX,wB;;AAoBhB,WAASI,cAAT,CAAwBQ,KAAxB,EAA+BX,UAA/B,EAA2C;AACzC,WAAOY,KAAKC,KAAL,CAAWF,QAAQX,UAAnB,IAAiCA,UAAxC;AACD,G;;AAlDMK,O","file":"histogram.js","sourcesContent":["import _ from 'lodash';\n\n/**\n * Convert series into array of series values.\n * @param data Array of series\n */\nexport function getSeriesValues(data) {\n  let values = [];\n\n  // Count histogam stats\n  for (let i = 0; i < data.length; i++) {\n    let series = data[i];\n    for (let j = 0; j < series.data.length; j++) {\n      if (series.data[j][1] !== null) {\n        values.push(series.data[j][1]);\n      }\n    }\n  }\n\n  return values;\n}\n\n/**\n * Convert array of values into timeseries-like histogram:\n * [[val_1, count_1], [val_2, count_2], ..., [val_n, count_n]]\n * @param values\n * @param bucketSize\n */\nexport function convertValuesToHistogram(values, bucketSize) {\n  let histogram = {};\n\n  for (let i = 0; i < values.length; i++) {\n    let bound = getBucketBound(values[i], bucketSize);\n    if (histogram[bound]) {\n      histogram[bound] = histogram[bound] + 1;\n    } else {\n      histogram[bound] = 1;\n    }\n  }\n\n  let histogam_series = _.map(histogram, (count, bound) => {\n    return [Number(bound), count];\n  });\n\n  // Sort by Y axis values\n  return _.sortBy(histogam_series, point => point[0]);\n}\n\nfunction getBucketBound(value, bucketSize) {\n  return Math.floor(value / bucketSize) * bucketSize;\n}\n"]}